// Time Complexity : O(n) n are the length of string
// Space Complexity : O(n) 
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No


// Your code here along with comments explaining your approach
sliding window solutions. keep the two pointers at the start of the string and move until we find a duplicate.
ans store the max length at every index.when we find the duplicate start removing the elements form start until
we reached the duplicate. repeat this until the end of the array and return max length in the end.




class Solution {
    public int lengthOfLongestSubstring(String s) {
        int i=0,max = 0,j=0;
        HashSet<Character>set = new HashSet<>();
        while(i<s.length() && j<s.length()){
            char ch = s.charAt(j);
            while(set.contains(ch)){
                set.remove(s.charAt(i));
                i++;
            }
            set.add(ch);
            max = Math.max(max,set.size());
            j++;
        }
        return max;
    }
}